{
    "ATTACHMENT": {
        "COLOR_ATTACHMENT0": 2000,
        "COLOR_ATTACHMENT1": 2001,
        "COLOR_ATTACHMENT2": 2002,
        "COLOR_ATTACHMENT3": 2003,
        "COLOR_ATTACHMENT4": 2004,
        "COLOR_ATTACHMENT5": 2005,
        "COLOR_ATTACHMENT6": 2006,
        "COLOR_ATTACHMENT7": 2007,
        "COLOR_ATTACHMENT8": 2008,
        "COLOR_ATTACHMENT9": 2009,
        "COLOR_ATTACHMENT10": 2010,
        "COLOR_ATTACHMENT11": 2011,
        "COLOR_ATTACHMENT12": 2012,
        "COLOR_ATTACHMENT13": 2013,
        "COLOR_ATTACHMENT14": 2014,
        "COLOR_ATTACHMENT15": 2015,
        "DEPTH_ATTACHMENT": 2020,
        "STENCIL_ATTACHMENT": 2021,
        "DEPTH_STENCIL_ATTACHMENT": 2030
    },
    "BLEND_EQUATION": {
        "ADD": 32774,
        "SUBTRACT": 32778,
        "REVERSE_SUBTRACT": 32779
    },
    "BLEND_FACTOR": {
        "ZERO": 0,
        "ONE": 1,
        "SRC_COLOR": 768,
        "ONE_MINUS_SRC_COLOR": 769,
        "SRC_ALPHA": 770,
        "ONE_MINUS_SRC_ALPHA": 771,
        "DST_ALPHA": 772,
        "ONE_MINUS_DST_ALPHA": 773,
        "DST_COLOR": 774,
        "ONE_MINUS_DST_COLOR": 775
    },
    "BLEND_TYPE": {
        "NONE": "none",
        "NORMAL": "normal",
        "ADD": "add",
        "SUB": "sub",
        "MUL": "mul",
        "CUSTOM": "custom"
    },
    "BUFFER_USAGE": {
        "STREAM_DRAW": 35040,
        "STREAM_READ": 35041,
        "STREAM_COPY": 35042,
        "STATIC_DRAW": 35044,
        "STATIC_READ": 35045,
        "STATIC_COPY": 35046,
        "DYNAMIC_DRAW": 35048,
        "DYNAMIC_READ": 35049,
        "DYNAMIC_COPY": 35050
    },
    "COMPARE_FUNC": {
        "LEQUAL": 515,
        "GEQUAL": 518,
        "LESS": 513,
        "GREATER": 516,
        "EQUAL": 514,
        "NOTEQUAL": 517,
        "ALWAYS": 519,
        "NEVER": 512
    },
    "CULL_FACE_TYPE": {
        "NONE": "none",
        "FRONT": "front",
        "BACK": "back",
        "FRONT_AND_BACK": "front_and_back"
    },
    "DRAW_BUFFER": {
        "DRAW_BUFFER0": 34853,
        "DRAW_BUFFER1": 34854,
        "DRAW_BUFFER2": 34855,
        "DRAW_BUFFER3": 34856,
        "DRAW_BUFFER4": 34857,
        "DRAW_BUFFER5": 34858,
        "DRAW_BUFFER6": 34859,
        "DRAW_BUFFER7": 34860,
        "DRAW_BUFFER8": 34861,
        "DRAW_BUFFER9": 34862,
        "DRAW_BUFFER10": 34863,
        "DRAW_BUFFER11": 34864,
        "DRAW_BUFFER12": 34865,
        "DRAW_BUFFER13": 34866,
        "DRAW_BUFFER14": 34867,
        "DRAW_BUFFER15": 34868
    },
    "DRAW_MODE": {
        "POINTS": 0,
        "LINES": 1,
        "LINE_LOOP": 2,
        "LINE_STRIP": 3,
        "TRIANGLES": 4,
        "TRIANGLE_STRIP": 5,
        "TRIANGLE_FAN": 6
    },
    "DRAW_SIDE": {
        "FRONT": "front",
        "BACK": "back",
        "DOUBLE": "double"
    },
    "DefaultLoadingManager": {
        "isLoading": true,
        "itemsLoaded": 13,
        "itemsTotal": 18
    },
    "ENVMAP_COMBINE_TYPE": {
        "MULTIPLY": "ENVMAP_BLENDING_MULTIPLY",
        "MIX": "ENVMAP_BLENDING_MIX",
        "ADD": "ENVMAP_BLENDING_ADD"
    },
    "EdgesBuilder": {},
    "ExtrudeShapeBuilder": {},
    "FOG_TYPE": {
        "NORMAL": "normal",
        "EXP2": "exp2"
    },
    "GeometryUtils": {},
    "LIGHT_TYPE": {
        "AMBIENT": "ambient",
        "HEMISPHERE": "hemisphere",
        "DIRECT": "direct",
        "POINT": "point",
        "SPOT": "spot"
    },
    "MATERIAL_TYPE": {
        "BASIC": "basic",
        "LAMBERT": "lambert",
        "PHONG": "phong",
        "PBR": "pbr",
        "PBR2": "pbr2",
        "MATCAP": "matcap",
        "POINT": "point",
        "LINE": "line",
        "SHADER": "shader",
        "DEPTH": "depth",
        "DISTANCE": "distance"
    },
    "OBJECT_TYPE": {
        "MESH": "mesh",
        "SKINNED_MESH": "skinned_mesh",
        "LIGHT": "light",
        "CAMERA": "camera",
        "SCENE": "scene",
        "GROUP": "group"
    },
    "OPERATION": {
        "KEEP": 7680,
        "REPLACE": 7681,
        "INCR": 7682,
        "DECR": 7683,
        "INVERT": 5386,
        "INCR_WRAP": 34055,
        "DECR_WRAP": 34056
    },
    "PIXEL_FORMAT": {
        "DEPTH_COMPONENT": 1000,
        "DEPTH_STENCIL": 1001,
        "STENCIL_INDEX8": 1002,
        "ALPHA": 1003,
        "RED": 1004,
        "RGB": 1005,
        "RGBA": 1006,
        "LUMINANCE": 1007,
        "LUMINANCE_ALPHA": 1008,
        "RED_INTEGER": 1010,
        "RG": 1011,
        "RG_INTEGER": 1012,
        "RGB_INTEGER": 1013,
        "RGBA_INTEGER": 1014,
        "R32F": 1100,
        "R16F": 1101,
        "R8": 1102,
        "RG32F": 1103,
        "RG16F": 1104,
        "RG8": 1105,
        "RGB32F": 1106,
        "RGB16F": 1107,
        "RGB8": 1108,
        "RGBA32F": 1109,
        "RGBA16F": 1110,
        "RGBA8": 1111,
        "RGBA4": 1112,
        "RGB5_A1": 1113,
        "DEPTH_COMPONENT32F": 1114,
        "DEPTH_COMPONENT24": 1115,
        "DEPTH_COMPONENT16": 1116,
        "DEPTH24_STENCIL8": 1117,
        "DEPTH32F_STENCIL8": 1118,
        "RGB_S3TC_DXT1": 1200,
        "RGBA_S3TC_DXT1": 1201,
        "RGBA_S3TC_DXT3": 1202,
        "RGBA_S3TC_DXT5": 1203,
        "RGB_PVRTC_4BPPV1": 1204,
        "RGB_PVRTC_2BPPV1": 1205,
        "RGBA_PVRTC_4BPPV1": 1206,
        "RGBA_PVRTC_2BPPV1": 1207,
        "RGB_ETC1": 1208,
        "RGBA_ASTC_4x4": 1209,
        "RGBA_BPTC": 1210
    },
    "PIXEL_TYPE": {
        "UNSIGNED_BYTE": 1500,
        "UNSIGNED_SHORT_5_6_5": 1501,
        "UNSIGNED_SHORT_4_4_4_4": 1502,
        "UNSIGNED_SHORT_5_5_5_1": 1503,
        "UNSIGNED_SHORT": 1504,
        "UNSIGNED_INT": 1505,
        "UNSIGNED_INT_24_8": 1506,
        "FLOAT": 1507,
        "HALF_FLOAT": 1508,
        "FLOAT_32_UNSIGNED_INT_24_8_REV": 1509,
        "BYTE": 1510,
        "SHORT": 1511,
        "INT": 1512
    },
    "QUERY_TYPE": {
        "ANY_SAMPLES_PASSED": 35887,
        "ANY_SAMPLES_PASSED_CONSERVATIVE": 36202,
        "TIME_ELAPSED": 35007
    },
    "SHADING_TYPE": {
        "SMOOTH_SHADING": "smooth_shading",
        "FLAT_SHADING": "flat_shading"
    },
    "SHADOW_TYPE": {
        "HARD": "hard",
        "POISSON_SOFT": "poisson_soft",
        "PCF3_SOFT": "pcf3_soft",
        "PCF5_SOFT": "pcf5_soft",
        "PCSS16_SOFT": "pcss16_soft",
        "PCSS32_SOFT": "pcss32_soft",
        "PCSS64_SOFT": "pcss64_soft"
    },
    "ShaderChunk": {
        "alphaTest_frag": "#ifdef ALPHATEST\n\tif ( outColor.a < ALPHATEST ) {\n\t\tdiscard;\n\t} else {\n\t\toutColor.a = u_Opacity;\n\t}\n#endif",
        "aoMap_pars_frag": "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\tvarying vec2 vAOMapUV;\n#endif",
        "aoMap_pars_vert": "#ifdef USE_AOMAP\n\tuniform mat3 aoMapUVTransform;\n\tvarying vec2 vAOMapUV;\n#endif",
        "aoMap_vert": "#ifdef USE_AOMAP\n\t#if (USE_AOMAP == 2)\n        vAOMapUV = (aoMapUVTransform * vec3(a_Uv2, 1.)).xy;\n    #else\n        vAOMapUV = (aoMapUVTransform * vec3(a_Uv, 1.)).xy;\n    #endif\n#endif",
        "aoMap_frag": "\n#ifdef USE_AOMAP\n    float ambientOcclusion = (texture2D(aoMap, vAOMapUV).r - 1.0) * aoMapIntensity + 1.0;\n    \n    reflectedLight.indirectDiffuse *= ambientOcclusion;\n    #if defined(USE_ENV_MAP) && defined(USE_PBR)\n        float dotNV = saturate(dot(N, V));\n        reflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, GGXRoughnessToBlinnExponent(roughness));\n    #endif\n#endif",
        "begin_frag": "vec4 outColor = vec4(u_Color, u_Opacity);",
        "begin_vert": "vec3 transformed = vec3(a_Position);\nvec3 objectNormal = vec3(a_Normal);\n#ifdef USE_TANGENT\n    vec3 objectTangent = vec3(a_Tangent.xyz);\n#endif",
        "bsdfs": "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nvec3 BRDF_Diffuse_Lambert(vec3 diffuseColor) {\n    return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent(const in vec3 F0, const in float dotNV, const in float roughness) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nvec3 BRDF_Specular_BlinnPhong(vec3 specularColor, vec3 N, vec3 L, vec3 V, float shininess) {\n    vec3 H = normalize(L + V);\n    float dotNH = saturate(dot(N, H));\n    float dotLH = saturate(dot(L, H));\n    vec3 F = F_Schlick(specularColor, dotLH);\n    float G = G_BlinnPhong_Implicit( );\n    float D = D_BlinnPhong(shininess, dotNH);\n    return F * G * D;\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nvec3 BRDF_Specular_GGX(vec3 specularColor, vec3 N, vec3 L, vec3 V, float roughness) {\n\tfloat alpha = pow2( roughness );\n\tvec3 H = normalize(L + V);\n\tfloat dotNL = saturate( dot(N, L) );\n\tfloat dotNV = saturate( dot(N, V) );\n\tfloat dotNH = saturate( dot(N, H) );\n\tfloat dotLH = saturate( dot(L, H) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * G * D;\n}\nvec3 BRDF_Specular_GGX_Environment(const in vec3 N, const in vec3 V, const in vec3 specularColor, const in float roughness) {\n\tfloat dotNV = saturate(dot(N, V));\n\tvec2 brdf = integrateSpecularBRDF(dotNV, roughness);\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment(const in vec3 N, const in vec3 V, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter) {\n\tfloat dotNV = saturate(dot(N, V));\n\tvec3 F = F_Schlick_RoughnessDependent(specularColor, dotNV, roughness);\n\tvec2 brdf = integrateSpecularBRDF(dotNV, roughness);\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + (1.0 - specularColor) * 0.047619;\tvec3 Fms = FssEss * Favg / (1.0 - Ems * Favg);\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
        "bumpMap_pars_frag": "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd(vec2 uv) {\n\t\tvec2 dSTdx = dFdx( uv );\n\t\tvec2 dSTdy = dFdy( uv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, uv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, uv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        "clippingPlanes_frag": "\n#if NUM_CLIPPING_PLANES > 0\n    vec4 plane;\n    #pragma unroll_loop_start\n    for (int i = 0; i < NUM_CLIPPING_PLANES; i++) {\n        plane = clippingPlanes[i];\n        if ( dot( -v_modelPos, plane.xyz ) > plane.w ) discard;\n    }\n    #pragma unroll_loop_end\n#endif",
        "clippingPlanes_pars_frag": "#if NUM_CLIPPING_PLANES > 0\n    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        "color_frag": "#ifdef USE_VCOLOR_RGB\n    outColor.rgb *= v_Color;\n#endif\n#ifdef USE_VCOLOR_RGBA\n    outColor *= v_Color;\n#endif",
        "color_pars_frag": "#ifdef USE_VCOLOR_RGB\n    varying vec3 v_Color;\n#endif\n#ifdef USE_VCOLOR_RGBA\n    varying vec4 v_Color;\n#endif",
        "color_pars_vert": "#ifdef USE_VCOLOR_RGB\n    attribute vec3 a_Color;\n    varying vec3 v_Color;\n#endif\n#ifdef USE_VCOLOR_RGBA\n    attribute vec4 a_Color;\n    varying vec4 v_Color;\n#endif",
        "color_vert": "#if defined(USE_VCOLOR_RGB) || defined(USE_VCOLOR_RGBA)\n    v_Color = a_Color;\n#endif",
        "common_frag": "uniform mat4 u_View;\nuniform float u_Opacity;\nuniform vec3 u_Color;\nuniform vec3 u_CameraPosition;\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};",
        "common_vert": "attribute vec3 a_Position;\nattribute vec3 a_Normal;\n#ifdef USE_TANGENT\n\tattribute vec4 a_Tangent;\n#endif\n#include <transpose>\n#include <inverse>\nuniform mat4 u_Projection;\nuniform mat4 u_View;\nuniform mat4 u_Model;\nuniform mat4 u_ProjectionView;\nuniform vec3 u_CameraPosition;\n#define EPSILON 1e-6\n#ifdef USE_MORPHTARGETS\n    attribute vec3 morphTarget0;\n    attribute vec3 morphTarget1;\n    attribute vec3 morphTarget2;\n    attribute vec3 morphTarget3;\n    #ifdef USE_MORPHNORMALS\n    \tattribute vec3 morphNormal0;\n    \tattribute vec3 morphNormal1;\n    \tattribute vec3 morphNormal2;\n    \tattribute vec3 morphNormal3;\n    #else\n    \tattribute vec3 morphTarget4;\n    \tattribute vec3 morphTarget5;\n    \tattribute vec3 morphTarget6;\n    \tattribute vec3 morphTarget7;\n    #endif\n#endif\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}",
        "diffuseMap_frag": "#ifdef USE_DIFFUSE_MAP\n    #if (USE_DIFFUSE_MAP == 2)\n        vec4 texelColor = texture2D(diffuseMap, v_Uv2);\n    #else \n        vec4 texelColor = texture2D(diffuseMap, v_Uv);\n    #endif\n    \n    texelColor = mapTexelToLinear(texelColor);\n    outColor *= texelColor;\n#endif",
        "diffuseMap_pars_frag": "#ifdef USE_DIFFUSE_MAP\n    uniform sampler2D diffuseMap;\n#endif",
        "emissiveMap_frag": "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D(emissiveMap, vEmissiveMapUV);\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        "emissiveMap_pars_frag": "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n\tvarying vec2 vEmissiveMapUV;\n#endif",
        "emissiveMap_vert": "#ifdef USE_EMISSIVEMAP\n\t#if (USE_EMISSIVEMAP == 2)\n        vEmissiveMapUV = (emissiveMapUVTransform * vec3(a_Uv2, 1.)).xy;\n    #else\n        vEmissiveMapUV = (emissiveMapUVTransform * vec3(a_Uv, 1.)).xy;\n    #endif\n#endif",
        "emissiveMap_pars_vert": "#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapUVTransform;\n\tvarying vec2 vEmissiveMapUV;\n#endif",
        "encodings_frag": "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        "encodings_pars_frag": "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}",
        "end_frag": "gl_FragColor = outColor;",
        "envMap_frag": "#ifdef USE_ENV_MAP\n    vec3 envDir;\n    #ifdef USE_VERTEX_ENVDIR\n        envDir = v_EnvDir;\n    #else\n        envDir = reflect(normalize(v_modelPos - u_CameraPosition), N);\n    #endif\n    vec4 envColor = textureCube(envMap, vec3(u_EnvMap_Flip * envDir.x, envDir.yz));\n    envColor = envMapTexelToLinear( envColor );\n    #ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutColor = mix(outColor, envColor * outColor, u_EnvMap_Intensity);\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutColor = mix(outColor, envColor, u_EnvMap_Intensity);\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutColor += envColor * u_EnvMap_Intensity;\n\t#endif\n#endif",
        "envMap_pars_frag": "#ifdef USE_ENV_MAP\n    #ifdef USE_VERTEX_ENVDIR\n        varying vec3 v_EnvDir;\n    #endif\n    uniform samplerCube envMap;\n    uniform float u_EnvMap_Flip;\n    uniform float u_EnvMap_Intensity;\n    uniform float u_EnvMapLight_Intensity;\n    uniform int maxMipLevel;\n#endif",
        "envMap_pars_vert": "#ifdef USE_ENV_MAP\n    #ifdef USE_VERTEX_ENVDIR\n        varying vec3 v_EnvDir;\n    #endif\n#endif",
        "envMap_vert": "\n#ifdef USE_ENV_MAP\n    #ifdef USE_VERTEX_ENVDIR\n        vec3 transformedNormal = (transposeMat4(inverseMat4(u_Model)) * vec4(objectNormal, 0.0)).xyz;\n        transformedNormal = normalize(transformedNormal);\n        v_EnvDir = reflect(normalize(worldPosition.xyz - u_CameraPosition), transformedNormal);\n    #endif\n#endif",
        "fog_frag": "#ifdef USE_FOG\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    #ifdef USE_EXP2_FOG\n        float fogFactor = 1.0 - exp(-u_FogDensity * u_FogDensity * depth * depth);\n    #else\n        float fogFactor = smoothstep(u_FogNear, u_FogFar, depth);\n    #endif\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, fogFactor);\n#endif",
        "fog_pars_frag": "#ifdef USE_FOG\n    uniform vec3 u_FogColor;\n    #ifdef USE_EXP2_FOG\n        uniform float u_FogDensity;\n    #else\n        uniform float u_FogNear;\n        uniform float u_FogFar;\n    #endif\n#endif",
        "inverse": "mat4 inverseMat4(mat4 m) {\n    float\n    a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n    a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n    a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n    a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n    b00 = a00 * a11 - a01 * a10,\n    b01 = a00 * a12 - a02 * a10,\n    b02 = a00 * a13 - a03 * a10,\n    b03 = a01 * a12 - a02 * a11,\n    b04 = a01 * a13 - a03 * a11,\n    b05 = a02 * a13 - a03 * a12,\n    b06 = a20 * a31 - a21 * a30,\n    b07 = a20 * a32 - a22 * a30,\n    b08 = a20 * a33 - a23 * a30,\n    b09 = a21 * a32 - a22 * a31,\n    b10 = a21 * a33 - a23 * a31,\n    b11 = a22 * a33 - a23 * a32,\n    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    return mat4(\n        a11 * b11 - a12 * b10 + a13 * b09,\n        a02 * b10 - a01 * b11 - a03 * b09,\n        a31 * b05 - a32 * b04 + a33 * b03,\n        a22 * b04 - a21 * b05 - a23 * b03,\n        a12 * b08 - a10 * b11 - a13 * b07,\n        a00 * b11 - a02 * b08 + a03 * b07,\n        a32 * b02 - a30 * b05 - a33 * b01,\n        a20 * b05 - a22 * b02 + a23 * b01,\n        a10 * b10 - a11 * b08 + a13 * b06,\n        a01 * b08 - a00 * b10 - a03 * b06,\n        a30 * b04 - a31 * b02 + a33 * b00,\n        a21 * b02 - a20 * b04 - a23 * b00,\n        a11 * b07 - a10 * b09 - a12 * b06,\n        a00 * b09 - a01 * b07 + a02 * b06,\n        a31 * b01 - a30 * b03 - a32 * b00,\n        a20 * b03 - a21 * b01 + a22 * b00) / det;\n}",
        "light_frag": "\n#if (defined(USE_PHONG) || defined(USE_PBR))\n    vec3 V = normalize(u_CameraPosition - v_modelPos);\n#endif\n#ifdef USE_PBR\n    #ifdef USE_PBR2\n        vec3 diffuseColor = outColor.xyz;\n        vec3 specularColor = specularFactor.xyz;\n        float roughness = max(1.0 - glossinessFactor, 0.0525);\n    #else\n        vec3 diffuseColor = outColor.xyz * (1.0 - metalnessFactor);\n        vec3 specularColor = mix(vec3(0.04), outColor.xyz, metalnessFactor);\n        float roughness = max(roughnessFactor, 0.0525);\n    #endif\n    vec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\n    float geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\n    roughness += geometryRoughness;\n    roughness = min(roughness, 1.0);\n#else\n    vec3 diffuseColor = outColor.xyz;\n    #ifdef USE_PHONG\n        vec3 specularColor = u_SpecularColor.xyz;\n        float shininess = u_Specular;\n    #endif\n#endif\n#ifdef USE_LIGHT\n    vec3 L;\n    float falloff;\n    float dotNL;\n    vec3 irradiance;\n    #if NUM_DIR_LIGHTS > 0\n        #pragma unroll_loop_start\n        for (int i = 0; i < NUM_DIR_LIGHTS; i++) {\n            L = normalize(-u_Directional[i].direction);\n            falloff = 1.0;\n            #if defined(USE_SHADOW) && (UNROLLED_LOOP_INDEX < NUM_DIR_SHADOWS)\n                #ifdef USE_PCSS_SOFT_SHADOW\n                    falloff *= getShadowWithPCSS(directionalDepthMap[i], directionalShadowMap[i], vDirectionalShadowCoord[i], u_DirectionalShadow[i].shadowMapSize, u_DirectionalShadow[i].shadowBias, u_DirectionalShadow[i].shadowParams);\n                #else\n                    falloff *= getShadow(directionalShadowMap[i], vDirectionalShadowCoord[i], u_DirectionalShadow[i].shadowMapSize, u_DirectionalShadow[i].shadowBias, u_DirectionalShadow[i].shadowParams);\n                #endif\n            #endif\n            dotNL = saturate(dot(N, L));\n            irradiance = u_Directional[i].color * falloff * dotNL * PI;\n            reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(diffuseColor);\n            #ifdef USE_PHONG\n                reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(specularColor, N, L, V, shininess) * specularStrength;\n            #endif\n            #ifdef USE_PBR\n                reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX(specularColor, N, L, V, roughness);\n            #endif\n        }\n        #pragma unroll_loop_end\n    #endif\n    #if NUM_POINT_LIGHTS > 0\n        vec3 worldV;\n        #pragma unroll_loop_start\n        for (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n            worldV = v_modelPos - u_Point[i].position;\n            L = -worldV;\n            falloff = pow(clamp(1. - length(L) / u_Point[i].distance, 0.0, 1.0), u_Point[i].decay);\n            L = normalize(L);\n            #if defined(USE_SHADOW) && (UNROLLED_LOOP_INDEX < NUM_POINT_SHADOWS)\n                falloff *= getPointShadow(pointShadowMap[i], vPointShadowCoord[i], u_PointShadow[i].shadowMapSize, u_PointShadow[i].shadowBias, u_PointShadow[i].shadowParams, u_PointShadow[i].shadowCameraRange);\n            #endif\n            dotNL = saturate(dot(N, L));\n            irradiance = u_Point[i].color * falloff * dotNL * PI;\n            reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(diffuseColor);\n            #ifdef USE_PHONG\n                reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(specularColor, N, L, V, shininess) * specularStrength;\n            #endif\n            #ifdef USE_PBR\n                reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX(specularColor, N, L, V, roughness);\n            #endif\n        }\n        #pragma unroll_loop_end\n    #endif\n    #if NUM_SPOT_LIGHTS > 0\n        float lightDistance;\n        float angleCos;\n        #pragma unroll_loop_start\n        for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\n            L = u_Spot[i].position - v_modelPos;\n            lightDistance = length(L);\n            L = normalize(L);\n            angleCos = dot(L, -normalize(u_Spot[i].direction));\n            falloff = smoothstep(u_Spot[i].coneCos, u_Spot[i].penumbraCos, angleCos);\n            falloff *= pow(clamp(1. - lightDistance / u_Spot[i].distance, 0.0, 1.0), u_Spot[i].decay);\n            #if defined(USE_SHADOW) && (UNROLLED_LOOP_INDEX < NUM_SPOT_SHADOWS)\n                #ifdef USE_PCSS_SOFT_SHADOW\n                    falloff *= getShadowWithPCSS(spotDepthMap[i], spotShadowMap[i], vSpotShadowCoord[i], u_SpotShadow[i].shadowMapSize, u_SpotShadow[i].shadowBias, u_SpotShadow[i].shadowParams);\n                #else\n                    falloff *= getShadow(spotShadowMap[i], vSpotShadowCoord[i], u_SpotShadow[i].shadowMapSize, u_SpotShadow[i].shadowBias, u_SpotShadow[i].shadowParams);\n                #endif\n            #endif\n            dotNL = saturate(dot(N, L));\n            irradiance = u_Spot[i].color * falloff * dotNL * PI;\n            reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(diffuseColor);\n            #ifdef USE_PHONG\n                reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(specularColor, N, L, V, shininess) * specularStrength;\n            #endif\n            #ifdef USE_PBR\n                reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX(specularColor, N, L, V, roughness);\n            #endif\n        }\n        #pragma unroll_loop_end\n    #endif\n    vec3 iblIrradiance = vec3(0., 0., 0.);\n    vec3 indirectIrradiance = vec3(0., 0., 0.);\n    vec3 indirectRadiance = vec3(0., 0., 0.);\n    #ifdef USE_AMBIENT_LIGHT\n        indirectIrradiance += u_AmbientLightColor * PI;\n    #endif\n    #if NUM_HEMI_LIGHTS > 0\n        float hemiDiffuseWeight;\n        #pragma unroll_loop_start\n        for (int i = 0; i < NUM_HEMI_LIGHTS; i++) {\n            L = normalize(u_Hemi[i].direction);\n            dotNL = dot(N, L);\n            hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n            indirectIrradiance += mix(u_Hemi[i].groundColor, u_Hemi[i].skyColor, hemiDiffuseWeight) * PI;\n        }\n        #pragma unroll_loop_end\n    #endif\n    #if defined(USE_ENV_MAP) && defined(USE_PBR)\n        vec3 envDir;\n        #ifdef USE_VERTEX_ENVDIR\n            envDir = v_EnvDir;\n        #else\n            envDir = reflect(normalize(v_modelPos - u_CameraPosition), N);\n        #endif\n        iblIrradiance += getLightProbeIndirectIrradiance(maxMipLevel, N);\n        indirectRadiance += getLightProbeIndirectRadiance(GGXRoughnessToBlinnExponent(roughness), maxMipLevel, envDir);\n    #endif\n    reflectedLight.indirectDiffuse += indirectIrradiance * BRDF_Diffuse_Lambert(diffuseColor);\n    #if defined(USE_ENV_MAP) && defined(USE_PBR)\n        float clearcoatDHR = 0.0;\n        float clearcoatInv = 1.0 - clearcoatDHR;\n        vec3 singleScattering = vec3(0.0);\n\t    vec3 multiScattering = vec3(0.0);\n        vec3 cosineWeightedIrradiance = iblIrradiance * RECIPROCAL_PI;\n        BRDF_Specular_Multiscattering_Environment(N, V, specularColor, roughness, singleScattering, multiScattering);\n        vec3 diffuse = diffuseColor * (1.0 - (singleScattering + multiScattering));\n        reflectedLight.indirectSpecular += clearcoatInv * indirectRadiance * singleScattering;\n        reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n        reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n    #endif\n#endif",
        "light_pars_frag": "#ifdef USE_AMBIENT_LIGHT\n    uniform vec3 u_AmbientLightColor;\n#endif\n#if NUM_HEMI_LIGHTS > 0\n    struct HemisphereLight {\n        vec3 direction;\n        vec3 skyColor;\n\t\tvec3 groundColor;\n    };\n    uniform HemisphereLight u_Hemi[NUM_HEMI_LIGHTS];\n#endif\n#if NUM_DIR_LIGHTS > 0\n    struct DirectLight {\n        vec3 direction;\n        vec3 color;\n    };\n    uniform DirectLight u_Directional[NUM_DIR_LIGHTS];\n#endif\n#if NUM_POINT_LIGHTS > 0\n    struct PointLight {\n        vec3 position;\n        vec3 color;\n        float distance;\n        float decay;\n    };\n    uniform PointLight u_Point[NUM_POINT_LIGHTS];\n#endif\n#if NUM_SPOT_LIGHTS > 0\n    struct SpotLight {\n        vec3 position;\n        vec3 color;\n        float distance;\n        float decay;\n        float coneCos;\n        float penumbraCos;\n        vec3 direction;\n    };\n    uniform SpotLight u_Spot[NUM_SPOT_LIGHTS];\n#endif\n#if defined(USE_PBR) && defined(USE_ENV_MAP)\n    vec3 getLightProbeIndirectIrradiance(const in int maxMIPLevel, const in vec3 N) {\n        vec3 coordVec = vec3(u_EnvMap_Flip * N.x, N.yz);\n    \t#ifdef TEXTURE_LOD_EXT\n    \t\tvec4 envMapColor = textureCubeLodEXT(envMap, coordVec, float(maxMIPLevel));\n    \t#else\n    \t\tvec4 envMapColor = textureCube(envMap, coordVec, float(maxMIPLevel));\n    \t#endif\n        envMapColor = envMapTexelToLinear(envMapColor);\n        return PI * envMapColor.rgb * u_EnvMap_Intensity * u_EnvMapLight_Intensity;\n    }\n    float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {\n    \tfloat maxMIPLevelScalar = float(maxMIPLevel);\n    \tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2(pow2(blinnShininessExponent) + 1.0);\n    \treturn clamp(desiredMIPLevel, 0.0, maxMIPLevelScalar);\n    }\n    vec3 getLightProbeIndirectRadiance(const in float blinnShininessExponent, const in int maxMIPLevel, const in vec3 envDir) {\n        float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);\n        vec3 coordVec = vec3(u_EnvMap_Flip * envDir.x, envDir.yz);\n        #ifdef TEXTURE_LOD_EXT\n    \t\tvec4 envMapColor = textureCubeLodEXT(envMap, coordVec, specularMIPLevel);\n    \t#else\n    \t\tvec4 envMapColor = textureCube(envMap, coordVec, specularMIPLevel);\n    \t#endif\n        envMapColor = envMapTexelToLinear(envMapColor);\n        return envMapColor.rgb * u_EnvMap_Intensity;\n    }\n    float computeSpecularOcclusion(const in float dotNV, const in float ambientOcclusion, const in float roughness) {\n    \treturn saturate(pow(dotNV + ambientOcclusion, exp2(-16.0 * roughness - 1.0)) - 1.0 + ambientOcclusion);\n    }\n#endif",
        "alphamap_pars_frag": "#ifdef USE_ALPHA_MAP\n\tuniform sampler2D alphaMap;\n\tvarying vec2 vAlphaMapUV;\n#endif",
        "alphamap_frag": "#ifdef USE_ALPHA_MAP\n\toutColor.a *= texture2D(alphaMap, vAlphaMapUV).g;\n#endif",
        "alphamap_pars_vert": "#ifdef USE_ALPHA_MAP\n    uniform mat3 alphaMapUVTransform;\n\tvarying vec2 vAlphaMapUV;\n#endif",
        "alphamap_vert": "#ifdef USE_ALPHA_MAP\n\t#if (USE_ALPHA_MAP == 2)\n        vAlphaMapUV = (alphaMapUVTransform * vec3(a_Uv2, 1.)).xy;\n    #else\n        vAlphaMapUV = (alphaMapUVTransform * vec3(a_Uv, 1.)).xy;\n    #endif\n#endif",
        "normalMap_pars_frag": "#ifdef USE_NORMAL_MAP\n    #if !defined(USE_TANGENT) || defined(FLAT_SHADED)\n        #include <tsn>\n    #endif\n    uniform sampler2D normalMap;\n    uniform vec2 normalScale;\n#endif",
        "normal_frag": "\n#ifdef FLAT_SHADED\n    vec3 fdx = vec3( dFdx( v_modelPos.x ), dFdx( v_modelPos.y ), dFdx( v_modelPos.z ) );\n    vec3 fdy = vec3( dFdy( v_modelPos.x ), dFdy( v_modelPos.y ), dFdy( v_modelPos.z ) );\n    vec3 N = normalize( cross( fdx, fdy ) );\n#else\n    vec3 N = normalize(v_Normal);\n    #ifdef DOUBLE_SIDED\n        N = N * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n    #endif  \n#endif\nvec3 geometryNormal = N;\n#ifdef USE_NORMAL_MAP\n    vec3 mapN = texture2D(normalMap, v_Uv).rgb * 2.0 - 1.0;\n    mapN.xy *= normalScale;\n    #if defined(USE_TANGENT) && !defined(FLAT_SHADED)\n        vec3 tangent = normalize(v_Tangent);\n        vec3 bitangent = normalize(v_Bitangent);\n        #ifdef DOUBLE_SIDED\n            tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n            bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n        #endif  \n        mat3 tspace = mat3(tangent, bitangent, N);\n    #else\n        mat3 tspace = tsn(N, v_modelPos, v_Uv);\n        mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n    #endif\n    N = normalize(tspace * mapN);\n#elif defined(USE_BUMPMAP)\n    N = perturbNormalArb(v_modelPos, N, dHdxy_fwd(v_Uv));\n#endif",
        "normal_pars_frag": "#ifndef FLAT_SHADED\n    varying vec3 v_Normal;\n    #ifdef USE_TANGENT\n        varying vec3 v_Tangent;\n\t\tvarying vec3 v_Bitangent;\n    #endif\n#endif",
        "normal_pars_vert": "#ifndef FLAT_SHADED\n    varying vec3 v_Normal;\n    #ifdef USE_TANGENT\n        varying vec3 v_Tangent;\n\t\tvarying vec3 v_Bitangent;\n    #endif\n#endif",
        "normal_vert": "#ifndef FLAT_SHADED\n    v_Normal = (transposeMat4(inverseMat4(u_Model)) * vec4(objectNormal, 0.0)).xyz;\n    #ifdef FLIP_SIDED\n    \tv_Normal = - v_Normal;\n    #endif\n    #ifdef USE_TANGENT\n        v_Tangent = (transposeMat4(inverseMat4(u_Model)) * vec4(objectTangent, 0.0)).xyz;\n        #ifdef FLIP_SIDED\n            v_Tangent = - v_Tangent;\n        #endif\n        v_Bitangent = normalize(cross(v_Normal, v_Tangent) * a_Tangent.w);\n    #endif\n#endif",
        "packing": "const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n    vec4 r = vec4( fract( v * PackFactors ), v );\n    r.yzw -= r.xyz * ShiftRight8;    return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n    return dot( v, UnpackFactors );\n}",
        "premultipliedAlpha_frag": "#ifdef USE_PREMULTIPLIED_ALPHA\n    gl_FragColor.rgb = gl_FragColor.rgb * gl_FragColor.a;\n#endif",
        "pvm_vert": "vec4 worldPosition = u_Model * vec4(transformed, 1.0);\ngl_Position = u_ProjectionView * worldPosition;",
        "dithering_frag": "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        "dithering_pars_frag": "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        "shadow": "#ifdef USE_SHADOW_SAMPLER\n    float computeShadow(sampler2DShadow shadowMap, vec3 shadowCoord) {\n        return texture2D( shadowMap, shadowCoord );\n    }\n#else\n    float computeShadow(sampler2D shadowMap, vec3 shadowCoord) {\n        return step(shadowCoord.z, unpackRGBAToDepth(texture2D(shadowMap, shadowCoord.xy)));\n    }\n#endif\nfloat computeShadowWithPoissonSampling(sampler2DShadow shadowMap, vec3 shadowCoord, float texelSize) {\n    vec3 poissonDisk[4];\n    poissonDisk[0] = vec3(-0.94201624, -0.39906216, 0);\n    poissonDisk[1] = vec3(0.94558609, -0.76890725, 0);\n    poissonDisk[2] = vec3(-0.094184101, -0.92938870, 0);\n    poissonDisk[3] = vec3(0.34495938, 0.29387760, 0);\n    return computeShadow(shadowMap, shadowCoord + poissonDisk[0] * texelSize) * 0.25 +\n        computeShadow(shadowMap, shadowCoord + poissonDisk[1] * texelSize) * 0.25 +\n        computeShadow(shadowMap, shadowCoord + poissonDisk[2] * texelSize) * 0.25 +\n        computeShadow(shadowMap, shadowCoord + poissonDisk[3] * texelSize) * 0.25;\n}\nfloat computeShadowWithPCF1(sampler2DShadow shadowSampler, vec3 shadowCoord) {\n    return computeShadow(shadowSampler, shadowCoord);\n}\nfloat computeShadowWithPCF3(sampler2DShadow shadowSampler, vec3 shadowCoord, vec2 shadowMapSizeAndInverse) {\n    vec2 uv = shadowCoord.xy * shadowMapSizeAndInverse.x;    uv += 0.5;    vec2 st = fract(uv);    vec2 base_uv = floor(uv) - 0.5;    base_uv *= shadowMapSizeAndInverse.y;\n    vec2 uvw0 = 3. - 2. * st;\n    vec2 uvw1 = 1. + 2. * st;\n    vec2 u = vec2((2. - st.x) / uvw0.x - 1., st.x / uvw1.x + 1.) * shadowMapSizeAndInverse.y;\n    vec2 v = vec2((2. - st.y) / uvw0.y - 1., st.y / uvw1.y + 1.) * shadowMapSizeAndInverse.y;\n    float shadow = 0.;\n    shadow += uvw0.x * uvw0.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[0], v[0]), shadowCoord.z));\n    shadow += uvw1.x * uvw0.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[1], v[0]), shadowCoord.z));\n    shadow += uvw0.x * uvw1.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[0], v[1]), shadowCoord.z));\n    shadow += uvw1.x * uvw1.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[1], v[1]), shadowCoord.z));\n    shadow = shadow / 16.;\n    return shadow;\n}\nfloat computeShadowWithPCF5(sampler2DShadow shadowSampler, vec3 shadowCoord, vec2 shadowMapSizeAndInverse) {\n    vec2 uv = shadowCoord.xy * shadowMapSizeAndInverse.x;    uv += 0.5;    vec2 st = fract(uv);    vec2 base_uv = floor(uv) - 0.5;    base_uv *= shadowMapSizeAndInverse.y;\n    vec2 uvw0 = 4. - 3. * st;\n    vec2 uvw1 = vec2(7.);\n    vec2 uvw2 = 1. + 3. * st;\n    vec3 u = vec3((3. - 2. * st.x) / uvw0.x - 2., (3. + st.x) / uvw1.x, st.x / uvw2.x + 2.) * shadowMapSizeAndInverse.y;\n    vec3 v = vec3((3. - 2. * st.y) / uvw0.y - 2., (3. + st.y) / uvw1.y, st.y / uvw2.y + 2.) * shadowMapSizeAndInverse.y;\n    float shadow = 0.;\n    shadow += uvw0.x * uvw0.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[0], v[0]), shadowCoord.z));\n    shadow += uvw1.x * uvw0.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[1], v[0]), shadowCoord.z));\n    shadow += uvw2.x * uvw0.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[2], v[0]), shadowCoord.z));\n    shadow += uvw0.x * uvw1.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[0], v[1]), shadowCoord.z));\n    shadow += uvw1.x * uvw1.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[1], v[1]), shadowCoord.z));\n    shadow += uvw2.x * uvw1.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[2], v[1]), shadowCoord.z));\n    shadow += uvw0.x * uvw2.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[0], v[2]), shadowCoord.z));\n    shadow += uvw1.x * uvw2.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[1], v[2]), shadowCoord.z));\n    shadow += uvw2.x * uvw2.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[2], v[2]), shadowCoord.z));\n    shadow = shadow / 144.;\n    return shadow;\n}\nfloat computeFallOff(float value, vec2 clipSpace, float frustumEdgeFalloff) {\n    float mask = smoothstep(1.0 - frustumEdgeFalloff, 1.00000012, clamp(dot(clipSpace, clipSpace), 0., 1.));\n    return mix(value, 1.0, mask);\n}\nfloat getShadow(sampler2DShadow shadowMap, vec4 shadowCoord, vec2 shadowMapSize, vec2 shadowBias, vec2 shadowParams) {\n    shadowCoord.xyz /= shadowCoord.w;\n    shadowCoord.z += shadowBias.x;\n    bvec4 inFrustumVec = bvec4 (shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0);\n    bool inFrustum = all(inFrustumVec);\n    bvec2 frustumTestVec = bvec2(inFrustum, shadowCoord.z <= 1.0);\n    bool frustumTest = all(frustumTestVec);\n    float shadow = 1.0;\n    if (frustumTest) {\n        #ifdef USE_HARD_SHADOW\n            shadow = computeShadow(shadowMap, shadowCoord.xyz);\n        #else\n            #ifdef USE_PCF3_SOFT_SHADOW\n                vec2 shadowMapSizeAndInverse = vec2(shadowMapSize.x, 1. / shadowMapSize.x);\n                shadow = computeShadowWithPCF3(shadowMap, shadowCoord.xyz, shadowMapSizeAndInverse);\n            #else\n                #ifdef USE_PCF5_SOFT_SHADOW\n                    vec2 shadowMapSizeAndInverse = vec2(shadowMapSize.x, 1. / shadowMapSize.x);\n                    shadow = computeShadowWithPCF5(shadowMap, shadowCoord.xyz, shadowMapSizeAndInverse);\n                #else\n                    float texelSize = shadowParams.x / shadowMapSize.x;\n                    shadow = computeShadowWithPoissonSampling(shadowMap, shadowCoord.xyz, texelSize);\n                #endif\n            #endif\n        #endif\n        shadow = computeFallOff(shadow, shadowCoord.xy * 2. - 1., shadowParams.y);\n    }\n    return shadow;\n}\nfloat textureCubeCompare(samplerCube depths, vec3 uv, float compare) {\n    return step(compare, unpackRGBAToDepth(textureCube(depths, uv)));\n}\nfloat getPointShadow(samplerCube shadowMap, vec4 shadowCoord, vec2 shadowMapSize, vec2 shadowBias, vec2 shadowParams, vec2 shadowCameraRange) {\n    vec3 V = shadowCoord.xyz;\n    float depth = (length(V) - shadowCameraRange.x) / (shadowCameraRange.y - shadowCameraRange.x);    depth += shadowBias.x;\n    #ifdef USE_HARD_SHADOW\n        return textureCubeCompare(shadowMap, normalize(V), depth);\n    #else\n        float texelSize = shadowParams.x / shadowMapSize.x;\n        vec3 poissonDisk[4];\n        poissonDisk[0] = vec3(-1.0, 1.0, -1.0);\n        poissonDisk[1] = vec3(1.0, -1.0, -1.0);\n        poissonDisk[2] = vec3(-1.0, -1.0, -1.0);\n        poissonDisk[3] = vec3(1.0, -1.0, 1.0);\n        return textureCubeCompare(shadowMap, normalize(V) + poissonDisk[0] * texelSize, depth) * 0.25 +\n            textureCubeCompare(shadowMap, normalize(V) + poissonDisk[1] * texelSize, depth) * 0.25 +\n            textureCubeCompare(shadowMap, normalize(V) + poissonDisk[2] * texelSize, depth) * 0.25 +\n            textureCubeCompare(shadowMap, normalize(V) + poissonDisk[3] * texelSize, depth) * 0.25;\n    #endif\n}\n#ifdef USE_PCSS_SOFT_SHADOW\n    const vec3 PoissonSamplers32[64] = vec3[64](\n        vec3(0.06407013, 0.05409927, 0.),\n        vec3(0.7366577, 0.5789394, 0.),\n        vec3(-0.6270542, -0.5320278, 0.),\n        vec3(-0.4096107, 0.8411095, 0.),\n        vec3(0.6849564, -0.4990818, 0.),\n        vec3(-0.874181, -0.04579735, 0.),\n        vec3(0.9989998, 0.0009880066, 0.),\n        vec3(-0.004920578, -0.9151649, 0.),\n        vec3(0.1805763, 0.9747483, 0.),\n        vec3(-0.2138451, 0.2635818, 0.),\n        vec3(0.109845, 0.3884785, 0.),\n        vec3(0.06876755, -0.3581074, 0.),\n        vec3(0.374073, -0.7661266, 0.),\n        vec3(0.3079132, -0.1216763, 0.),\n        vec3(-0.3794335, -0.8271583, 0.),\n        vec3(-0.203878, -0.07715034, 0.),\n        vec3(0.5912697, 0.1469799, 0.),\n        vec3(-0.88069, 0.3031784, 0.),\n        vec3(0.5040108, 0.8283722, 0.),\n        vec3(-0.5844124, 0.5494877, 0.),\n        vec3(0.6017799, -0.1726654, 0.),\n        vec3(-0.5554981, 0.1559997, 0.),\n        vec3(-0.3016369, -0.3900928, 0.),\n        vec3(-0.5550632, -0.1723762, 0.),\n        vec3(0.925029, 0.2995041, 0.),\n        vec3(-0.2473137, 0.5538505, 0.),\n        vec3(0.9183037, -0.2862392, 0.),\n        vec3(0.2469421, 0.6718712, 0.),\n        vec3(0.3916397, -0.4328209, 0.),\n        vec3(-0.03576927, -0.6220032, 0.),\n        vec3(-0.04661255, 0.7995201, 0.),\n        vec3(0.4402924, 0.3640312, 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.)\n    );\n    const vec3 PoissonSamplers64[64] = vec3[64](\n        vec3(-0.613392, 0.617481, 0.),\n        vec3(0.170019, -0.040254, 0.),\n        vec3(-0.299417, 0.791925, 0.),\n        vec3(0.645680, 0.493210, 0.),\n        vec3(-0.651784, 0.717887, 0.),\n        vec3(0.421003, 0.027070, 0.),\n        vec3(-0.817194, -0.271096, 0.),\n        vec3(-0.705374, -0.668203, 0.),\n        vec3(0.977050, -0.108615, 0.),\n        vec3(0.063326, 0.142369, 0.),\n        vec3(0.203528, 0.214331, 0.),\n        vec3(-0.667531, 0.326090, 0.),\n        vec3(-0.098422, -0.295755, 0.),\n        vec3(-0.885922, 0.215369, 0.),\n        vec3(0.566637, 0.605213, 0.),\n        vec3(0.039766, -0.396100, 0.),\n        vec3(0.751946, 0.453352, 0.),\n        vec3(0.078707, -0.715323, 0.),\n        vec3(-0.075838, -0.529344, 0.),\n        vec3(0.724479, -0.580798, 0.),\n        vec3(0.222999, -0.215125, 0.),\n        vec3(-0.467574, -0.405438, 0.),\n        vec3(-0.248268, -0.814753, 0.),\n        vec3(0.354411, -0.887570, 0.),\n        vec3(0.175817, 0.382366, 0.),\n        vec3(0.487472, -0.063082, 0.),\n        vec3(-0.084078, 0.898312, 0.),\n        vec3(0.488876, -0.783441, 0.),\n        vec3(0.470016, 0.217933, 0.),\n        vec3(-0.696890, -0.549791, 0.),\n        vec3(-0.149693, 0.605762, 0.),\n        vec3(0.034211, 0.979980, 0.),\n        vec3(0.503098, -0.308878, 0.),\n        vec3(-0.016205, -0.872921, 0.),\n        vec3(0.385784, -0.393902, 0.),\n        vec3(-0.146886, -0.859249, 0.),\n        vec3(0.643361, 0.164098, 0.),\n        vec3(0.634388, -0.049471, 0.),\n        vec3(-0.688894, 0.007843, 0.),\n        vec3(0.464034, -0.188818, 0.),\n        vec3(-0.440840, 0.137486, 0.),\n        vec3(0.364483, 0.511704, 0.),\n        vec3(0.034028, 0.325968, 0.),\n        vec3(0.099094, -0.308023, 0.),\n        vec3(0.693960, -0.366253, 0.),\n        vec3(0.678884, -0.204688, 0.),\n        vec3(0.001801, 0.780328, 0.),\n        vec3(0.145177, -0.898984, 0.),\n        vec3(0.062655, -0.611866, 0.),\n        vec3(0.315226, -0.604297, 0.),\n        vec3(-0.780145, 0.486251, 0.),\n        vec3(-0.371868, 0.882138, 0.),\n        vec3(0.200476, 0.494430, 0.),\n        vec3(-0.494552, -0.711051, 0.),\n        vec3(0.612476, 0.705252, 0.),\n        vec3(-0.578845, -0.768792, 0.),\n        vec3(-0.772454, -0.090976, 0.),\n        vec3(0.504440, 0.372295, 0.),\n        vec3(0.155736, 0.065157, 0.),\n        vec3(0.391522, 0.849605, 0.),\n        vec3(-0.620106, -0.328104, 0.),\n        vec3(0.789239, -0.419965, 0.),\n        vec3(-0.545396, 0.538133, 0.),\n        vec3(-0.178564, -0.596057, 0.)\n    );\n    float getRand(vec2 seed) {\n        return fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n    float computeShadowWithPCSS(sampler2D depthSampler, sampler2DShadow shadowSampler, vec3 shadowCoord, float shadowMapSizeInverse, float lightSizeUV, int searchTapCount, int pcfTapCount, vec3[64] poissonSamplers) {\n        float depthMetric = shadowCoord.z;\n        float blockerDepth = 0.0;\n        float sumBlockerDepth = 0.0;\n        float numBlocker = 0.0;\n        for (int i = 0; i < searchTapCount; i++) {\n            blockerDepth = unpackRGBAToDepth(texture(depthSampler, shadowCoord.xy + (lightSizeUV * shadowMapSizeInverse * PoissonSamplers32[i].xy)));\n            if (blockerDepth < depthMetric) {\n                sumBlockerDepth += blockerDepth;\n                numBlocker++;\n            }\n        }\n        if (numBlocker < 1.0) {\n            return 1.0;\n        }\n        float avgBlockerDepth = sumBlockerDepth / numBlocker;\n        float AAOffset = shadowMapSizeInverse * 10.;\n        float penumbraRatio = ((depthMetric - avgBlockerDepth) + AAOffset);\n        float filterRadius = penumbraRatio * lightSizeUV * shadowMapSizeInverse;\n        float random = getRand(shadowCoord.xy);        float rotationAngle = random * 3.1415926;\n        vec2 rotationVector = vec2(cos(rotationAngle), sin(rotationAngle));\n        float shadow = 0.;\n        for (int i = 0; i < pcfTapCount; i++) {\n            vec3 offset = poissonSamplers[i];\n            offset = vec3(offset.x * rotationVector.x - offset.y * rotationVector.y, offset.y * rotationVector.x + offset.x * rotationVector.y, 0.);\n            shadow += texture(shadowSampler, shadowCoord + offset * filterRadius);\n        }\n        shadow /= float(pcfTapCount);\n        shadow = mix(shadow, 1., depthMetric - avgBlockerDepth);\n        return shadow;\n    }\n    float getShadowWithPCSS(sampler2D depthSampler, sampler2DShadow shadowMap, vec4 shadowCoord, vec2 shadowMapSize, vec2 shadowBias, vec2 shadowParams) {\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias.x;\n        bvec4 inFrustumVec = bvec4 (shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0);\n        bool inFrustum = all(inFrustumVec);\n        bvec2 frustumTestVec = bvec2(inFrustum, shadowCoord.z <= 1.0);\n        bool frustumTest = all(frustumTestVec);\n        float shadow = 1.0;\n        if (frustumTest) {\n            #ifdef USE_PCSS16_SOFT_SHADOW\n                shadow = computeShadowWithPCSS(depthSampler, shadowMap, shadowCoord.xyz, 1. / shadowMapSize.x, 0.1 * shadowMapSize.x, 16, 16, PoissonSamplers32);\n            #else\n                #ifdef USE_PCSS32_SOFT_SHADOW\n                    shadow = computeShadowWithPCSS(depthSampler, shadowMap, shadowCoord.xyz, 1. / shadowMapSize.x, 0.1 * shadowMapSize.x, 16, 32, PoissonSamplers32);\n                #else\n                    shadow = computeShadowWithPCSS(depthSampler, shadowMap, shadowCoord.xyz, 1. / shadowMapSize.x, 0.1 * shadowMapSize.x, 32, 64, PoissonSamplers64);\n                #endif\n            #endif\n            shadow = computeFallOff(shadow, shadowCoord.xy * 2. - 1., shadowParams.y);\n        }\n        return shadow;\n    }\n#endif",
        "shadowMap_frag": "#ifdef USE_SHADOW\n#endif",
        "shadowMap_pars_frag": "#ifdef USE_SHADOW\n\t#if NUM_DIR_SHADOWS > 0\n\t\tuniform sampler2DShadow directionalShadowMap[NUM_DIR_SHADOWS];\n\t\tvarying vec4 vDirectionalShadowCoord[NUM_DIR_SHADOWS];\n\t\t#ifdef USE_PCSS_SOFT_SHADOW\n\t\t\tuniform sampler2D directionalDepthMap[NUM_DIR_SHADOWS];\n\t\t#endif\n\t\tstruct DirectLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t};\n\t\tuniform DirectLightShadow u_DirectionalShadow[NUM_DIR_SHADOWS];\n\t#endif\n\t#if NUM_POINT_SHADOWS > 0\n\t\tuniform samplerCube pointShadowMap[NUM_POINT_SHADOWS];\n\t\tvarying vec4 vPointShadowCoord[NUM_POINT_SHADOWS];\n\t\tstruct PointLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t\tvec2 shadowCameraRange;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow u_PointShadow[NUM_POINT_LIGHTS];\n\t#endif\n\t#if NUM_SPOT_SHADOWS > 0\n\t\tuniform sampler2DShadow spotShadowMap[NUM_SPOT_SHADOWS];\n\t\tvarying vec4 vSpotShadowCoord[NUM_SPOT_SHADOWS];\n\t\t#ifdef USE_PCSS_SOFT_SHADOW\n\t\t\tuniform sampler2D spotDepthMap[NUM_SPOT_SHADOWS];\n\t\t#endif\n\t\tstruct SpotLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t};\n\t\tuniform SpotLightShadow u_SpotShadow[NUM_SPOT_LIGHTS];\n\t#endif\n\t#include <packing>\n\t#include <shadow>\n#endif",
        "shadowMap_pars_vert": "#ifdef USE_SHADOW\n\t#if NUM_DIR_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[NUM_DIR_SHADOWS];\n\t\tvarying vec4 vDirectionalShadowCoord[NUM_DIR_SHADOWS];\n\t\tstruct DirectLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t};\n\t\tuniform DirectLightShadow u_DirectionalShadow[NUM_DIR_SHADOWS];\n\t#endif\n\t#if NUM_POINT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[NUM_POINT_SHADOWS];\n\t\tvarying vec4 vPointShadowCoord[NUM_POINT_SHADOWS];\n\t\tstruct PointLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t\tvec2 shadowCameraRange;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow u_PointShadow[NUM_POINT_LIGHTS];\n\t#endif\n\t#if NUM_SPOT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[NUM_SPOT_SHADOWS];\n\t\tvarying vec4 vSpotShadowCoord[NUM_SPOT_SHADOWS];\n\t\tstruct SpotLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t};\n\t\tuniform SpotLightShadow u_SpotShadow[NUM_SPOT_LIGHTS];\n\t#endif\n#endif",
        "shadowMap_vert": "\n#ifdef USE_SHADOW\n\t#if NUM_DIR_SHADOWS > 0 || NUM_POINT_SHADOWS > 0 || NUM_SPOT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = (transposeMat4(inverseMat4(u_Model)) * vec4(objectNormal, 0.0)).xyz;\n\t\tshadowWorldNormal = normalize(shadowWorldNormal);\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_DIR_SHADOWS; i++) {\n\t\t\tshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * u_DirectionalShadow[i].shadowBias[1], 0);\n\t\t\tvDirectionalShadowCoord[i] = directionalShadowMatrix[i] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_POINT_SHADOWS; i++) {\n\t\t\tshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * u_PointShadow[i].shadowBias[1], 0);\n\t\t\tvPointShadowCoord[i] = pointShadowMatrix[i] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_SPOT_SHADOWS; i++) {\n\t\t\tshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * u_SpotShadow[i].shadowBias[1], 0);\n\t\t\tvSpotShadowCoord[i] = spotShadowMatrix[i] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif",
        "morphnormal_vert": "#ifdef USE_MORPHNORMALS\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        "morphtarget_pars_vert": "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        "morphtarget_vert": "#ifdef USE_MORPHTARGETS\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n        transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n        transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n        transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n        transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        "skinning_pars_vert": "#ifdef USE_SKINNING\n    attribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n    uniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n    #ifdef BONE_TEXTURE\n        uniform sampler2D boneTexture;\n        uniform int boneTextureSize;\n        mat4 getBoneMatrix( const in float i ) {\n            float j = i * 4.0;\n            float x = mod( j, float( boneTextureSize ) );\n            float y = floor( j / float( boneTextureSize ) );\n            float dx = 1.0 / float( boneTextureSize );\n            float dy = 1.0 / float( boneTextureSize );\n            y = dy * ( y + 0.5 );\n            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n            mat4 bone = mat4( v1, v2, v3, v4 );\n            return bone;\n        }\n    #else\n        uniform mat4 boneMatrices[MAX_BONES];\n        mat4 getBoneMatrix(const in float i) {\n            mat4 bone = boneMatrices[int(i)];\n            return bone;\n        }\n    #endif\n#endif",
        "skinning_vert": "#ifdef USE_SKINNING\n    mat4 boneMatX = getBoneMatrix( skinIndex.x );\n    mat4 boneMatY = getBoneMatrix( skinIndex.y );\n    mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n    mat4 boneMatW = getBoneMatrix( skinIndex.w );\n    vec4 skinVertex = bindMatrix * vec4(transformed, 1.0);\n    vec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned = bindMatrixInverse * skinned;\n    transformed = skinned.xyz / skinned.w;\n#endif",
        "skinnormal_vert": "#ifdef USE_SKINNING\n    mat4 skinMatrix = mat4( 0.0 );\n    skinMatrix += skinWeight.x * boneMatX;\n    skinMatrix += skinWeight.y * boneMatY;\n    skinMatrix += skinWeight.z * boneMatZ;\n    skinMatrix += skinWeight.w * boneMatW;\n    skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n    objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n    #ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        "specularMap_frag": "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, v_Uv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        "specularMap_pars_frag": "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        "transpose": "mat4 transposeMat4(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n        vec4(i0.x, i1.x, i2.x, i3.x),\n        vec4(i0.y, i1.y, i2.y, i3.y),\n        vec4(i0.z, i1.z, i2.z, i3.z),\n        vec4(i0.w, i1.w, i2.w, i3.w)\n    );\n    return outMatrix;\n}",
        "tsn": "mat3 tsn(vec3 N, vec3 V, vec2 uv) {\n    vec3 q0 = vec3(dFdx(V.x), dFdx(V.y), dFdx(V.z));\n    vec3 q1 = vec3(dFdy(V.x), dFdy(V.y), dFdy(V.z));\n    vec2 st0 = dFdx( uv.st );\n    vec2 st1 = dFdy( uv.st );\n    float scale = sign( st1.t * st0.s - st0.t * st1.s );\n    vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n    vec3 T = normalize( ( -q0 * st1.s + q1 * st0.s ) * scale );\n    mat3 tsn = mat3( S, T, N );\n    return tsn;\n}",
        "uv_pars_frag": "#ifdef USE_UV1\n    varying vec2 v_Uv;\n#endif\n#ifdef USE_UV2\n    varying vec2 v_Uv2;\n#endif",
        "uv_pars_vert": "#if defined(USE_UV1) || defined(USE_UV2)\n    uniform mat3 uvTransform;\n#endif\n#ifdef USE_UV1\n    attribute vec2 a_Uv;\n    varying vec2 v_Uv;\n#endif\n#ifdef USE_UV2\n    attribute vec2 a_Uv2;\n    varying vec2 v_Uv2;\n#endif",
        "uv_vert": "#ifdef USE_UV1\n    v_Uv = (uvTransform * vec3(a_Uv, 1.)).xy;\n#endif\n#ifdef USE_UV2\n    v_Uv2 = (uvTransform * vec3(a_Uv2, 1.)).xy;\n#endif",
        "modelPos_pars_frag": "varying vec3 v_modelPos;",
        "modelPos_pars_vert": "varying vec3 v_modelPos;",
        "modelPos_vert": "\nv_modelPos = worldPosition.xyz;",
        "logdepthbuf_frag": "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        "logdepthbuf_pars_frag": "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        "logdepthbuf_pars_vert": "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tuniform float logDepthCameraNear;\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t\tuniform float logDepthCameraNear;\n\t#endif\n#endif",
        "logdepthbuf_vert": "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w - logDepthCameraNear;\n\t\tvIsPerspective = float( isPerspectiveMatrix( u_Projection ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( u_Projection ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w - logDepthCameraNear + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif"
    },
    "ShaderLib": {
        "basic_frag": "#include <common_frag>\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <modelPos_pars_frag>\n#if defined(USE_ENV_MAP) && !defined(USE_VERTEX_ENVDIR)\n    #include <normalMap_pars_frag>\n    #include <normal_pars_frag>    \n#endif\n#include <envMap_pars_frag>\n#include <aoMap_pars_frag>\n#include <fog_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n    #include <clippingPlanes_frag>\n    #include <logdepthbuf_frag>\n    #include <begin_frag>\n    #include <color_frag>\n    #include <diffuseMap_frag>\n    #include <alphamap_frag>\n    #include <alphaTest_frag>\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    reflectedLight.indirectDiffuse += vec3(1.0);\n    #include <aoMap_frag>\n    reflectedLight.indirectDiffuse *= outColor.xyz;\n    outColor.xyz = reflectedLight.indirectDiffuse;\n    #if defined(USE_ENV_MAP) && !defined(USE_VERTEX_ENVDIR)\n        #include <normal_frag>\n    #endif\n    #include <envMap_frag>\n    #include <end_frag>\n    #include <encodings_frag>\n    #include <premultipliedAlpha_frag>\n    #include <fog_frag>\n}",
        "basic_vert": "#include <common_vert>\n#include <uv_pars_vert>\n#include <color_pars_vert>\n#include <modelPos_pars_vert>\n#if defined(USE_ENV_MAP) && !defined(USE_VERTEX_ENVDIR)\n    #include <normal_pars_vert>\n#endif\n#include <envMap_pars_vert>\n#include <aoMap_pars_vert>\n#include <alphamap_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n    #include <begin_vert>\n    #include <morphtarget_vert>\n    #include <skinning_vert>\n    #include <pvm_vert>\n    #include <logdepthbuf_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <modelPos_vert>\n    #ifdef USE_ENV_MAP\n        #include <morphnormal_vert>\n        #include <skinnormal_vert>\n        #ifndef USE_VERTEX_ENVDIR\n            #include <normal_vert>\n        #endif  \n    #endif\n    #include <envMap_vert>\n    #include <aoMap_vert>\n    #include <alphamap_vert>\n}",
        "depth_frag": "#include <common_frag>\n#include <diffuseMap_pars_frag>\n#include <modelPos_pars_frag>\n#include <uv_pars_frag>\n#include <packing>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n    #include <clippingPlanes_frag>\n    #if defined(USE_DIFFUSE_MAP) && defined(ALPHATEST)\n        vec4 texelColor = texture2D( diffuseMap, v_Uv );\n        float alpha = texelColor.a * u_Opacity;\n        if(alpha < ALPHATEST) discard;\n    #endif\n    #include <logdepthbuf_frag>\n    \n    #ifdef DEPTH_PACKING_RGBA\n        gl_FragColor = packDepthToRGBA(gl_FragCoord.z);\n    #else\n        gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), u_Opacity );\n    #endif\n}",
        "depth_vert": "#include <common_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <uv_pars_vert>\n#include <modelPos_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n    #include <uv_vert>\n    #include <begin_vert>\n    #include <morphtarget_vert>\n    #include <skinning_vert>\n    #include <pvm_vert>\n    #include <logdepthbuf_vert>\n    #include <modelPos_vert>\n}",
        "distance_frag": "#include <common_frag>\nuniform float nearDistance;\nuniform float farDistance;\n#include <modelPos_pars_frag>\n#include <packing>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n    #include <clippingPlanes_frag>\n    \n    float dist = length( v_modelPos - u_CameraPosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n    gl_FragColor = packDepthToRGBA(dist);\n}",
        "distance_vert": "#include <common_vert>\n#include <modelPos_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\nvoid main() {\n    #include <begin_vert>\n    #include <morphtarget_vert>\n    #include <skinning_vert>\n    #include <pvm_vert>\n    #include <modelPos_vert>\n}",
        "lambert_frag": "#define USE_LAMBERT\n#include <common_frag>\n#include <dithering_pars_frag>\nuniform vec3 emissive;\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <normalMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <bumpMap_pars_frag>\n#include <light_pars_frag>\n#include <normal_pars_frag>\n#include <modelPos_pars_frag>\n#include <bsdfs>\n#include <envMap_pars_frag>\n#include <aoMap_pars_frag>\n#include <shadowMap_pars_frag>\n#include <fog_pars_frag>\n#include <emissiveMap_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n    #include <clippingPlanes_frag>\n    #include <logdepthbuf_frag>\n    #include <begin_frag>\n    #include <color_frag>\n    #include <diffuseMap_frag>\n    #include <alphamap_frag>\n    #include <alphaTest_frag>\n    #include <normal_frag>\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    #include <light_frag>\n    #include <aoMap_frag>\n    outColor.xyz = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n    #include <envMap_frag>\n    #include <shadowMap_frag>\n    vec3 totalEmissiveRadiance = emissive;\n    #include <emissiveMap_frag>\n    outColor.xyz += totalEmissiveRadiance;\n    #include <end_frag>\n    #include <encodings_frag>\n    #include <premultipliedAlpha_frag>\n    #include <fog_frag>\n    #include <dithering_frag>\n}",
        "lambert_vert": "#define USE_LAMBERT\n#include <common_vert>\n#include <normal_pars_vert>\n#include <uv_pars_vert>\n#include <color_pars_vert>\n#include <modelPos_pars_vert>\n#include <envMap_pars_vert>\n#include <aoMap_pars_vert>\n#include <alphamap_pars_vert>\n#include <emissiveMap_pars_vert>\n#include <shadowMap_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n    #include <begin_vert>\n    #include <morphtarget_vert>\n    #include <morphnormal_vert>\n    #include <skinning_vert>\n    #include <skinnormal_vert>\n    #include <pvm_vert>\n    #include <normal_vert>\n    #include <logdepthbuf_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <modelPos_vert>\n    #include <envMap_vert>\n    #include <aoMap_vert>\n    #include <alphamap_vert>\n    #include <emissiveMap_vert>\n    #include <shadowMap_vert>\n}",
        "normaldepth_frag": "#include <common_frag>\n#include <diffuseMap_pars_frag>\n#include <uv_pars_frag>\n#include <packing>\n#include <normal_pars_frag>\n#include <logdepthbuf_pars_frag>\nvoid main() {\n    #if defined(USE_DIFFUSE_MAP) && defined(ALPHATEST)\n        vec4 texelColor = texture2D( diffuseMap, v_Uv );\n        float alpha = texelColor.a * u_Opacity;\n        if(alpha < ALPHATEST) discard;\n    #endif\n    #include <logdepthbuf_frag>\n    vec4 packedNormalDepth;\n    packedNormalDepth.xyz = normalize(v_Normal) * 0.5 + 0.5;\n    packedNormalDepth.w = gl_FragCoord.z;\n    gl_FragColor = packedNormalDepth;\n}",
        "normaldepth_vert": "#include <common_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <normal_pars_vert>\n#include <uv_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n    #include <uv_vert>\n    #include <begin_vert>\n    #include <morphtarget_vert>\n    #include <morphnormal_vert>\n    #include <skinning_vert>\n    #include <skinnormal_vert>\n    #include <normal_vert>\n    #include <pvm_vert>\n    #include <logdepthbuf_vert>\n}",
        "pbr_frag": "#define USE_PBR\n#include <common_frag>\n#include <dithering_pars_frag>\nuniform float u_Metalness;\n#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif\nuniform float u_Roughness;\n#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif\nuniform vec3 emissive;\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <normalMap_pars_frag>\n#include <bumpMap_pars_frag>\n#include <envMap_pars_frag>\n#include <aoMap_pars_frag>\n#include <light_pars_frag>\n#include <normal_pars_frag>\n#include <modelPos_pars_frag>\n#include <bsdfs>\n#include <shadowMap_pars_frag>\n#include <fog_pars_frag>\n#include <emissiveMap_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n    #include <clippingPlanes_frag>\n    #include <logdepthbuf_frag>\n    #include <begin_frag>\n    #include <color_frag>\n    #include <diffuseMap_frag>\n    #include <alphamap_frag>\n    #include <alphaTest_frag>\n    #include <normal_frag>\n    float roughnessFactor = u_Roughness;\n    #ifdef USE_ROUGHNESSMAP\n    \tvec4 texelRoughness = texture2D( roughnessMap, v_Uv );\n    \troughnessFactor *= texelRoughness.g;\n    #endif\n    float metalnessFactor = u_Metalness;\n    #ifdef USE_METALNESSMAP\n    \tvec4 texelMetalness = texture2D( metalnessMap, v_Uv );\n    \tmetalnessFactor *= texelMetalness.b;\n    #endif\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    #include <light_frag>\n    #include <aoMap_frag>\n    outColor.xyz = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n    #include <shadowMap_frag>\n    vec3 totalEmissiveRadiance = emissive;\n    #include <emissiveMap_frag>\n    outColor.xyz += totalEmissiveRadiance;\n    #include <end_frag>\n    #include <encodings_frag>\n    #include <premultipliedAlpha_frag>\n    #include <fog_frag>\n    #include <dithering_frag>\n}",
        "pbr_vert": "#define USE_PBR\n#include <common_vert>\n#include <normal_pars_vert>\n#include <uv_pars_vert>\n#include <color_pars_vert>\n#include <modelPos_pars_vert>\n#include <envMap_pars_vert>\n#include <aoMap_pars_vert>\n#include <alphamap_pars_vert>\n#include <emissiveMap_pars_vert>\n#include <shadowMap_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n    #include <begin_vert>\n    #include <morphtarget_vert>\n    #include <morphnormal_vert>\n    #include <skinning_vert>\n    #include <skinnormal_vert>\n    #include <pvm_vert>\n    #include <normal_vert>\n    #include <logdepthbuf_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <modelPos_vert>\n    #include <envMap_vert>\n    #include <aoMap_vert>\n    #include <alphamap_vert>\n    #include <emissiveMap_vert>\n    #include <shadowMap_vert>\n}",
        "pbr2_frag": "#define USE_PBR\n#define USE_PBR2\n#include <common_frag>\n#include <dithering_pars_frag>\nuniform vec3 u_SpecularColor;\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\nuniform float glossiness;\n#ifdef USE_GLOSSINESSMAP\n\tuniform sampler2D glossinessMap;\n#endif\nuniform vec3 emissive;\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <normalMap_pars_frag>\n#include <bumpMap_pars_frag>\n#include <envMap_pars_frag>\n#include <aoMap_pars_frag>\n#include <light_pars_frag>\n#include <normal_pars_frag>\n#include <modelPos_pars_frag>\n#include <bsdfs>\n#include <shadowMap_pars_frag>\n#include <fog_pars_frag>\n#include <emissiveMap_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n    #include <clippingPlanes_frag>\n    #include <logdepthbuf_frag>\n    #include <begin_frag>\n    #include <color_frag>\n    #include <diffuseMap_frag>\n    #include <alphamap_frag>\n    #include <alphaTest_frag>\n    #include <normal_frag>\n    vec3 specularFactor = u_SpecularColor;\n    #ifdef USE_SPECULARMAP\n        vec4 texelSpecular = texture2D(specularMap, v_Uv);\n        texelSpecular = sRGBToLinear(texelSpecular);\n        specularFactor *= texelSpecular.rgb;\n    #endif\n    float glossinessFactor = glossiness;\n    #ifdef USE_GLOSSINESSMAP\n        vec4 texelGlossiness = texture2D(glossinessMap, v_Uv);\n        glossinessFactor *= texelGlossiness.a;\n    #endif\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    #include <light_frag>\n    #include <aoMap_frag>\n    outColor.xyz = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n    #include <shadowMap_frag>\n    vec3 totalEmissiveRadiance = emissive;\n    #include <emissiveMap_frag>\n    outColor.xyz += totalEmissiveRadiance;\n    #include <end_frag>\n    #include <encodings_frag>\n    #include <premultipliedAlpha_frag>\n    #include <fog_frag>\n    #include <dithering_frag>\n}",
        "pbr2_vert": "#define USE_PBR\n#include <common_vert>\n#include <normal_pars_vert>\n#include <uv_pars_vert>\n#include <color_pars_vert>\n#include <modelPos_pars_vert>\n#include <envMap_pars_vert>\n#include <aoMap_pars_vert>\n#include <alphamap_pars_vert>\n#include <emissiveMap_pars_vert>\n#include <shadowMap_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n    #include <begin_vert>\n    #include <morphtarget_vert>\n    #include <morphnormal_vert>\n    #include <skinning_vert>\n    #include <skinnormal_vert>\n    #include <pvm_vert>\n    #include <normal_vert>\n    #include <logdepthbuf_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <modelPos_vert>\n    #include <envMap_vert>\n    #include <aoMap_vert>\n    #include <alphamap_vert>\n    #include <emissiveMap_vert>\n    #include <shadowMap_vert>\n}",
        "matcap_frag": "#define MATCAP\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common_frag>\n#include <dithering_pars_frag>\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <normalMap_pars_frag>\n#include <modelPos_pars_frag>\n#include <bumpMap_pars_frag>\n#include <normal_pars_frag>\n#include <fog_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n    #include <clippingPlanes_frag>\n    #include <logdepthbuf_frag>\n    #include <begin_frag>\n    #include <color_frag>\n    #include <diffuseMap_frag>\n    #include <alphamap_frag>\n    #include <alphaTest_frag>\n    #include <normal_frag>\n    vec3 viewDir = normalize(vViewPosition);\n\tvec3 x = normalize(vec3(viewDir.z, 0.0, -viewDir.x));\n\tvec3 y = cross(viewDir, x);\n    vec3 viewN = (u_View * vec4(N, 0.0)).xyz;\n\tvec2 uv = vec2(dot(x, viewN), dot(y, viewN)) * 0.495 + 0.5;\n    #ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D(matcap, uv);\n\t\tmatcapColor = matcapTexelToLinear(matcapColor);\n\t#else\n\t\tvec4 matcapColor = vec4(1.0);\n\t#endif\n\toutColor.rgb *= matcapColor.rgb;\n    #include <end_frag>\n    #include <encodings_frag>\n    #include <premultipliedAlpha_frag>\n    #include <fog_frag>\n    #include <dithering_frag>\n}",
        "matcap_vert": "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common_vert>\n#include <normal_pars_vert>\n#include <uv_pars_vert>\n#include <color_pars_vert>\n#include <alphamap_pars_vert>\n#include <modelPos_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n    #include <begin_vert>\n    #include <morphtarget_vert>\n    #include <morphnormal_vert>\n    #include <skinning_vert>\n    #include <skinnormal_vert>\n    #include <pvm_vert>\n    #include <normal_vert>\n    #include <logdepthbuf_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <alphamap_vert>\n    #include <modelPos_vert>\n    vec4 mvPosition = u_View * worldPosition;\n    vViewPosition = - mvPosition.xyz;\n}",
        "phong_frag": "#define USE_PHONG\n#include <common_frag>\n#include <dithering_pars_frag>\nuniform float u_Specular;\nuniform vec3 u_SpecularColor;\n#include <specularMap_pars_frag>\nuniform vec3 emissive;\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <normalMap_pars_frag>\n#include <bumpMap_pars_frag>\n#include <light_pars_frag>\n#include <normal_pars_frag>\n#include <modelPos_pars_frag>\n#include <bsdfs>\n#include <envMap_pars_frag>\n#include <aoMap_pars_frag>\n#include <shadowMap_pars_frag>\n#include <fog_pars_frag>\n#include <emissiveMap_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n    #include <clippingPlanes_frag>\n    #include <logdepthbuf_frag>\n    #include <begin_frag>\n    #include <color_frag>\n    #include <diffuseMap_frag>\n    #include <alphamap_frag>\n    #include <alphaTest_frag>\n    #include <normal_frag>\n    #include <specularMap_frag>\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    #include <light_frag>\n    #include <aoMap_frag>\n    outColor.xyz = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n    #include <envMap_frag>\n    #include <shadowMap_frag>\n    vec3 totalEmissiveRadiance = emissive;\n    #include <emissiveMap_frag>\n    outColor.xyz += totalEmissiveRadiance;\n    #include <end_frag>\n    #include <encodings_frag>\n    #include <premultipliedAlpha_frag>\n    #include <fog_frag>\n    #include <dithering_frag>\n}",
        "phong_vert": "#define USE_PHONG\n#include <common_vert>\n#include <normal_pars_vert>\n#include <uv_pars_vert>\n#include <color_pars_vert>\n#include <modelPos_pars_vert>\n#include <envMap_pars_vert>\n#include <aoMap_pars_vert>\n#include <alphamap_pars_vert>\n#include <emissiveMap_pars_vert>\n#include <shadowMap_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n    #include <begin_vert>\n    #include <morphtarget_vert>\n    #include <morphnormal_vert>\n    #include <skinning_vert>\n    #include <skinnormal_vert>\n    #include <pvm_vert>\n    #include <normal_vert>\n    #include <logdepthbuf_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <modelPos_vert>\n    #include <envMap_vert>\n    #include <aoMap_vert>\n    #include <alphamap_vert>\n    #include <emissiveMap_vert>\n    #include <shadowMap_vert>\n}",
        "point_frag": "#include <common_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <fog_pars_frag>\n#include <logdepthbuf_pars_frag>\nvoid main() {\n    #include <begin_frag>\n    #include <color_frag>\n    #include <logdepthbuf_frag>\n    #ifdef USE_DIFFUSE_MAP\n        outColor *= texture2D(diffuseMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n    #endif\n    #include <end_frag>\n    #include <encodings_frag>\n    #include <premultipliedAlpha_frag>\n    #include <fog_frag>\n}",
        "point_vert": "#include <common_vert>\n#include <color_pars_vert>\n#include <logdepthbuf_pars_vert>\nuniform float u_PointSize;\nuniform float u_PointScale;\nvoid main() {\n    #include <begin_vert>\n    #include <pvm_vert>\n    #include <color_vert>\n    vec4 mvPosition = u_View * u_Model * vec4(transformed, 1.0);\n    #ifdef USE_SIZEATTENUATION\n        gl_PointSize = u_PointSize * ( u_PointScale / - mvPosition.z );\n    #else\n        gl_PointSize = u_PointSize;\n    #endif\n    #include <logdepthbuf_vert>\n}"
    },
    "TEXEL_ENCODING_TYPE": {
        "LINEAR": "linear",
        "SRGB": "sRGB",
        "RGBE": "RGBE",
        "RGBM7": "RGBM7",
        "RGBM16": "RGBM16",
        "RGBD": "RGBD",
        "GAMMA": "Gamma"
    },
    "TEXTURE_FILTER": {
        "NEAREST": 9728,
        "LINEAR": 9729,
        "NEAREST_MIPMAP_NEAREST": 9984,
        "LINEAR_MIPMAP_NEAREST": 9985,
        "NEAREST_MIPMAP_LINEAR": 9986,
        "LINEAR_MIPMAP_LINEAR": 9987
    },
    "TEXTURE_WRAP": {
        "REPEAT": 10497,
        "CLAMP_TO_EDGE": 33071,
        "MIRRORED_REPEAT": 33648
    },
    "VERTEX_COLOR": {
        "NONE": 0,
        "RGB": 1,
        "RGBA": 2
    },
    "WEBGL_COMPARE_FUNC": {
        "LEQUAL": 515,
        "GEQUAL": 518,
        "LESS": 513,
        "GREATER": 516,
        "EQUAL": 514,
        "NOTEQUAL": 517,
        "ALWAYS": 519,
        "NEVER": 512
    },
    "WEBGL_OP": {
        "KEEP": 7680,
        "REPLACE": 7681,
        "INCR": 7682,
        "DECR": 7683,
        "INVERT": 5386,
        "INCR_WRAP": 34055,
        "DECR_WRAP": 34056
    },
    "WEBGL_PIXEL_FORMAT": {
        "DEPTH_COMPONENT": 1000,
        "DEPTH_STENCIL": 1001,
        "STENCIL_INDEX8": 1002,
        "ALPHA": 1003,
        "RED": 1004,
        "RGB": 1005,
        "RGBA": 1006,
        "LUMINANCE": 1007,
        "LUMINANCE_ALPHA": 1008,
        "RED_INTEGER": 1010,
        "RG": 1011,
        "RG_INTEGER": 1012,
        "RGB_INTEGER": 1013,
        "RGBA_INTEGER": 1014,
        "R32F": 1100,
        "R16F": 1101,
        "R8": 1102,
        "RG32F": 1103,
        "RG16F": 1104,
        "RG8": 1105,
        "RGB32F": 1106,
        "RGB16F": 1107,
        "RGB8": 1108,
        "RGBA32F": 1109,
        "RGBA16F": 1110,
        "RGBA8": 1111,
        "RGBA4": 1112,
        "RGB5_A1": 1113,
        "DEPTH_COMPONENT32F": 1114,
        "DEPTH_COMPONENT24": 1115,
        "DEPTH_COMPONENT16": 1116,
        "DEPTH24_STENCIL8": 1117,
        "DEPTH32F_STENCIL8": 1118,
        "RGB_S3TC_DXT1": 1200,
        "RGBA_S3TC_DXT1": 1201,
        "RGBA_S3TC_DXT3": 1202,
        "RGBA_S3TC_DXT5": 1203,
        "RGB_PVRTC_4BPPV1": 1204,
        "RGB_PVRTC_2BPPV1": 1205,
        "RGBA_PVRTC_4BPPV1": 1206,
        "RGBA_PVRTC_2BPPV1": 1207,
        "RGB_ETC1": 1208,
        "RGBA_ASTC_4x4": 1209,
        "RGBA_BPTC": 1210
    },
    "WEBGL_PIXEL_TYPE": {
        "UNSIGNED_BYTE": 1500,
        "UNSIGNED_SHORT_5_6_5": 1501,
        "UNSIGNED_SHORT_4_4_4_4": 1502,
        "UNSIGNED_SHORT_5_5_5_1": 1503,
        "UNSIGNED_SHORT": 1504,
        "UNSIGNED_INT": 1505,
        "UNSIGNED_INT_24_8": 1506,
        "FLOAT": 1507,
        "HALF_FLOAT": 1508,
        "FLOAT_32_UNSIGNED_INT_24_8_REV": 1509,
        "BYTE": 1510,
        "SHORT": 1511,
        "INT": 1512
    },
    "WEBGL_TEXTURE_FILTER": {
        "NEAREST": 9728,
        "LINEAR": 9729,
        "NEAREST_MIPMAP_NEAREST": 9984,
        "LINEAR_MIPMAP_NEAREST": 9985,
        "NEAREST_MIPMAP_LINEAR": 9986,
        "LINEAR_MIPMAP_LINEAR": 9987
    },
    "WEBGL_TEXTURE_TYPE": {
        "TEXTURE_2D": 3553,
        "TEXTURE_CUBE_MAP": 34067,
        "TEXTURE_3D": 32879
    },
    "WEBGL_TEXTURE_WRAP": {
        "REPEAT": 10497,
        "CLAMP_TO_EDGE": 33071,
        "MIRRORED_REPEAT": 33648
    },
    "colorMappingShader": {
        "colormapping_pars_frag": "\n#ifdef COLOR_MAPPING\n  uniform sampler2D colorMapping;\n  uniform float colorMappingIntensity;\n#endif\n",
        "colormapping_frag": "\n#ifdef COLOR_MAPPING\n  float gray = clamp( dot( outColor.rgb, vec3(0.333, 0.333, 0.333) ), 0.0, 1.0 );\n  outColor.rgb = mix( outColor.rgb, texture2D( colorMapping, vec2( gray, 0.5 ) ).rgb, colorMappingIntensity );\n#endif\n"
    },
    "gpu_pickerShader": {
        "gpu_picker_instanceStates_pars_vert": "\n#ifdef USE_GPUPICKER\n\t#ifdef USE_INSTANCING\n        attribute float instanceStates;\n\t#endif\n\n\tvarying float vinstanceStates;\n#endif\n",
        "gpu_picker_instanceStates_vert": "\n#ifdef USE_GPUPICKER\n\t#ifdef USE_INSTANCING\n        vinstanceStates = instanceStates;\n\t#endif\n#endif\n",
        "gpu_picker_instanceStates_pars_frag": "\n#ifdef USE_GPUPICKER\n\t#ifdef USE_INSTANCING\n        varying float vinstanceStates;\n\t#endif\n#endif\n",
        "gpu_picker_instanceStates_frag": "\n#ifdef USE_GPUPICKER\n    #ifdef USE_INSTANCING\n        if(vinstanceStates == 0.0){\n            discard;\n        }\n    #endif\n#endif\n",
        "gpu_picker_pars_vert": "\n#ifdef USE_GPUPICKER\n\t#ifdef USE_INSTANCING\n\t\tattribute float instanceID;\n\t#endif\n\n\t#ifdef USE_ATTRIBUTES_ID\n\t\tattribute float ids;\n\t#endif\n\n\tuniform float baseId;\n\t\n\tvarying vec3 vPickColor;\n\n\tvec3 packPickIdToRGB(float pickId) {\n\t\tvec3 a = fract(vec3(1.0 / 255.0, 1.0 / (255.0 * 255.0), 1.0 / (255.0 * 255.0 * 255.0)) * pickId);\n\t\ta -= a.xxy * vec3(0.0, 1.0 / 255.0, 1.0 / 255.0);\n\t\treturn a;\n\t}\n#endif\n",
        "gpu_picker_id_vert": "\n#ifdef USE_GPUPICKER\n\t#ifdef USE_ATTRIBUTES_ID\n\t\tvPickColor = packPickIdToRGB(ids);\n\t#else\n\t\t#ifdef USE_INSTANCING\n\t\t\tvPickColor = packPickIdToRGB(instanceID);\n\t\t#else\n\t\t\tvPickColor = packPickIdToRGB(baseId);\n\t\t#endif\n\t#endif\n#endif\n",
        "gpu_picker_point_size_vert": "\n#ifdef USE_GPUPICKER\n\tgl_PointSize = size * (scale / length(mvPosition.xyz));\n#endif\n",
        "gpu_picker_pars_frag": "\n#ifdef USE_GPUPICKER\n\tvarying vec3 vPickColor;\n#endif\n",
        "gpu_picker_id_frag": "\n#ifdef USE_GPUPICKER\n\tgl_FragColor = vec4(vPickColor, 1.);\n#endif\n"
    },
    "instanceShader": {
        "instance_pars_vert": "\n#ifdef USE_INSTANCING\n\t\n\tattribute mat4 instanceMatrix;\n\n\t#if defined(USE_VCOLOR_RGB) || defined(USE_VCOLOR_RGBA)\n\t\t// attribute vec3 instanceColor;\n\t#endif\n\t\n#endif\n",
        "instance_normal_vert": "\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\tobjectNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\tobjectNormal = im * objectNormal;\n#endif\n",
        "instance_position_vert": "\n#ifdef USE_INSTANCING\n\ttransformed.xyz = ( instanceMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n",
        "instance_color_vert": "\n#ifdef USE_INSTANCING\n\t#if defined(USE_VCOLOR_RGB) || defined(USE_VCOLOR_RGBA)\n\n\t\t// v_Color.xyz = instanceColor.xyz;\n\t\t// v_Color.xyz *= instanceColor.xyz;\n\n\t#endif\n#endif\n"
    },
    "lightShader": {
        "light_frag": "\n// Use v_modelPos from modelPos_pars_frag\n// Use geometryNormal, N from normal_frag\n\n#ifdef USE_LIGHT\n\n    #ifdef USE_PBR\n        #ifdef USE_PBR2\n            vec3 diffuseColor = outColor.xyz;\n            vec3 specularColor = specularFactor.xyz;\n\t\t\tfloat roughness = max(1.0 - glossinessFactor, 0.0525);\n        #else\n            vec3 diffuseColor = outColor.xyz * (1.0 - metalnessFactor);\n            vec3 specularColor = mix(vec3(0.04), outColor.xyz, metalnessFactor);\n            float roughness = max(roughnessFactor, 0.0525);\n        #endif\n\n        vec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\n        float geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\n        roughness += geometryRoughness;\n\n        roughness = min(roughness, 1.0);\n    #else\n        vec3 diffuseColor = outColor.xyz;\n        #ifdef USE_PHONG\n            vec3 specularColor = u_SpecularColor.xyz;\n            float shininess = u_Specular;\n        #endif\n    #endif\n\n    #if (defined(USE_PHONG) || defined(USE_PBR))\n        vec3 V = normalize(u_CameraPosition - v_modelPos);\n    #endif\n\n    vec3 L;\n    float falloff;\n    float dotNL;\n    vec3 irradiance;\n\n    #if NUM_DIR_LIGHTS > 0\n\n        #pragma unroll_loop_start\n        for (int i = 0; i < NUM_DIR_LIGHTS; i++) {\n            L = normalize(-u_Directional[i].direction);\n            falloff = 1.0;\n\n            #if defined(USE_SHADOW) && (UNROLLED_LOOP_INDEX < NUM_DIR_SHADOWS)\n                #ifdef USE_PCSS_SOFT_SHADOW\n                    falloff *= getShadowWithPCSS(directionalDepthMap[i], directionalShadowMap[i], vDirectionalShadowCoord[i], u_DirectionalShadow[i].shadowMapSize, u_DirectionalShadow[i].shadowBias, u_DirectionalShadow[i].shadowParams);\n                #else\n                    falloff *= getShadow(directionalShadowMap[i], vDirectionalShadowCoord[i], u_DirectionalShadow[i].shadowMapSize, u_DirectionalShadow[i].shadowBias, u_DirectionalShadow[i].shadowParams);\n                #endif\n            #endif\n\n            dotNL = saturate(dot(N, L));\n            irradiance = u_Directional[i].color * falloff * dotNL * PI;\n\n            reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(diffuseColor);\n\n            #ifdef USE_PHONG\n                reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(specularColor, N, L, V, shininess) * specularStrength;\n            #endif\n\n            #ifdef USE_PBR\n                reflectedLight.directSpecular += specularFactor * irradiance * BRDF_Specular_GGX(specularColor, N, L, V, roughness);    // Modification : add specular factor\n            #endif\n        }\n        #pragma unroll_loop_end\n    #endif\n\n    #if NUM_POINT_LIGHTS > 0\n        vec3 worldV;\n\n        #pragma unroll_loop_start\n        for (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n            worldV = v_modelPos - u_Point[i].position;\n\n            L = -worldV;\n            falloff = pow(clamp(1. - length(L) / u_Point[i].distance, 0.0, 1.0), u_Point[i].decay);\n            L = normalize(L);\n\n            #if defined(USE_SHADOW) && (UNROLLED_LOOP_INDEX < NUM_POINT_SHADOWS)\n                falloff *= getPointShadow(pointShadowMap[i], vPointShadowCoord[i], u_PointShadow[i].shadowMapSize, u_PointShadow[i].shadowBias, u_PointShadow[i].shadowParams, u_PointShadow[i].shadowCameraRange);\n            #endif\n\n            dotNL = saturate(dot(N, L));\n            irradiance = u_Point[i].color * falloff * dotNL * PI;\n\n            reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(diffuseColor);\n\n            #ifdef USE_PHONG\n                reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(specularColor, N, L, V, shininess) * specularStrength;\n            #endif\n\n            #ifdef USE_PBR\n                reflectedLight.directSpecular += specularFactor * irradiance * BRDF_Specular_GGX(specularColor, N, L, V, roughness);    // Modification : add specular factor\n            #endif\n        }\n        #pragma unroll_loop_end\n    #endif\n\n    #if NUM_SPOT_LIGHTS > 0\n        float lightDistance;\n        float angleCos;\n\n        #pragma unroll_loop_start\n        for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\n            L = u_Spot[i].position - v_modelPos;\n            lightDistance = length(L);\n            L = normalize(L);\n            angleCos = dot(L, -normalize(u_Spot[i].direction));\n\n            falloff = smoothstep(u_Spot[i].coneCos, u_Spot[i].penumbraCos, angleCos);\n            falloff *= pow(clamp(1. - lightDistance / u_Spot[i].distance, 0.0, 1.0), u_Spot[i].decay);\n\n            #if defined(USE_SHADOW) && (UNROLLED_LOOP_INDEX < NUM_SPOT_SHADOWS)\n                #ifdef USE_PCSS_SOFT_SHADOW\n                    falloff *= getShadowWithPCSS(spotDepthMap[i], spotShadowMap[i], vSpotShadowCoord[i], u_SpotShadow[i].shadowMapSize, u_SpotShadow[i].shadowBias, u_SpotShadow[i].shadowParams);\n                #else\n                    falloff *= getShadow(spotShadowMap[i], vSpotShadowCoord[i], u_SpotShadow[i].shadowMapSize, u_SpotShadow[i].shadowBias, u_SpotShadow[i].shadowParams);\n                #endif\n            #endif\n\n            dotNL = saturate(dot(N, L));\n            irradiance = u_Spot[i].color * falloff * dotNL * PI;\n\n            reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(diffuseColor);\n\n            #ifdef USE_PHONG\n                reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(specularColor, N, L, V, shininess) * specularStrength;\n            #endif\n\n            #ifdef USE_PBR\n                reflectedLight.directSpecular += specularFactor * irradiance * BRDF_Specular_GGX(specularColor, N, L, V, roughness);    // Modification : add specular factor\n            #endif\n        }\n        #pragma unroll_loop_end\n    #endif\n\n    vec3 iblIrradiance = vec3(0., 0., 0.);\n    vec3 indirectIrradiance = vec3(0., 0., 0.);\n    vec3 indirectRadiance = vec3(0., 0., 0.);\n\n    #ifdef USE_AMBIENT_LIGHT\n        indirectIrradiance += u_AmbientLightColor * PI;\n    #endif\n\n    #if NUM_HEMI_LIGHTS > 0\n        float hemiDiffuseWeight;\n\n        #pragma unroll_loop_start\n        for (int i = 0; i < NUM_HEMI_LIGHTS; i++) {\n            L = normalize(u_Hemi[i].direction);\n\n            dotNL = dot(N, L);\n            hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n            indirectIrradiance += mix(u_Hemi[i].groundColor, u_Hemi[i].skyColor, hemiDiffuseWeight) * PI;\n        }\n        #pragma unroll_loop_end\n    #endif\n\n    // TODO light map\n\n    #if defined(USE_ENV_MAP) && defined(USE_PBR)\n        vec3 envDir;\n        #ifdef USE_VERTEX_ENVDIR\n            envDir = v_EnvDir;\n        #else\n            envDir = reflect(normalize(v_modelPos - u_CameraPosition), N);\n        #endif\n        iblIrradiance += getLightProbeIndirectIrradiance(maxMipLevel, N);\n        indirectRadiance += getLightProbeIndirectRadiance(GGXRoughnessToBlinnExponent(roughness), maxMipLevel, envDir);\n    #endif\n\n    reflectedLight.indirectDiffuse += indirectIrradiance * BRDF_Diffuse_Lambert(diffuseColor);\n\n    #if defined(USE_ENV_MAP) && defined(USE_PBR)\n        // reflectedLight.indirectSpecular += indirectRadiance * BRDF_Specular_GGX_Environment(N, V, specularColor, roughness);\n\n        float clearcoatDHR = 0.0; // TODO for clearcoat\n\n        float clearcoatInv = 1.0 - clearcoatDHR;\n\n        // Both indirect specular and indirect diffuse light accumulate here\n\n        vec3 singleScattering = vec3(0.0);\n\t    vec3 multiScattering = vec3(0.0);\n\n        vec3 cosineWeightedIrradiance = iblIrradiance * RECIPROCAL_PI;\n\n        BRDF_Specular_Multiscattering_Environment(N, V, specularColor, roughness, singleScattering, multiScattering);\n\n        vec3 diffuse = diffuseColor * (1.0 - (singleScattering + multiScattering));\n\n        reflectedLight.indirectSpecular += clearcoatInv * indirectRadiance * singleScattering;\n        reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n        reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n    #endif\n\n#endif\n",
        "simulate_basic_1_frag": "\n#ifdef SIMULATE_BASIC\n    reflectedLight.indirectDiffuse += vec3(1.0);\n#endif\n",
        "simulate_basic_2_frag": "\n#ifdef SIMULATE_BASIC\n    reflectedLight.indirectDiffuse *= outColor.xyz;\n    outColor.xyz = reflectedLight.indirectDiffuse;\n#else\n    outColor.xyz = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n#endif\n"
    },
    "skyBox_vert": "\n#include <common_vert>\nvarying vec3 vDir;\nuniform mat4 rotationMatrix;\n\nvoid main() {\n    mat4 o_model = rotationMatrix * u_Model;\n\tvDir = (o_model * vec4(a_Position, 0.0)).xyz;\n\tgl_Position = u_ProjectionView * u_Model * vec4(a_Position, 1.0);\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n}\n",
    "uvShader": {
        "uv_pars_vert": "\n#if defined(USE_UV1) || defined(USE_UV2)\n    uniform mat3 uvTransform;\n#endif\n\n#ifdef USE_UV1\n    attribute vec2 a_Uv;\n    varying vec2 v_Uv;\n#endif\n\n#ifdef USE_UV2\n    attribute vec2 a_Uv2;\n    varying vec2 v_Uv2;\n#endif\n\n#ifdef USE_UV3\n    attribute vec2 a_Uv3;\n#endif\n",
        "alphamap_vert": "\n#ifdef USE_ALPHA_MAP\n\n\t#if (USE_ALPHA_MAP == 2)\n        vAlphaMapUV = (alphaMapUVTransform * vec3(a_Uv2, 1.)).xy;\n    #elif (USE_ALPHA_MAP == 3)\n        vAlphaMapUV = (alphaMapUVTransform * vec3(a_Uv3, 1.)).xy;\n    #else\n        vAlphaMapUV = (alphaMapUVTransform * vec3(a_Uv, 1.)).xy;\n    #endif\n\n#endif\n",
        "emissivemap_vert": "\n#ifdef USE_EMISSIVEMAP\n\t#if (USE_EMISSIVEMAP == 2)\n\t\tvEmissiveMapUV = (emissiveMapUVTransform * vec3(a_Uv2, 1.)).xy;\n    #elif (USE_EMISSIVEMAP == 3)\n        vEmissiveMapUV = (emissiveMapUVTransform * vec3(a_Uv3, 1.)).xy;\n\t#else\n\t\tvEmissiveMapUV = (emissiveMapUVTransform * vec3(a_Uv, 1.)).xy;\n\t#endif\n#endif\n",
        "emissivemap_frag": "\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D(emissiveMap, vEmissiveMapUV);\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n\t#ifdef USE_PBR\n\t\t#ifdef USE_SIDE_EMISSIVE\n\t\t\tvec3 emissiveUp = vec3(0., 1., 0.);\n\n\t\t\ttotalEmissiveRadiance.rgb *= totalEmissiveRadiance.rgb * (1. - abs(dot(v_Normal, emissiveUp)));\n\t\t#endif\n\t#endif\n\n#endif\n"
    },
    "uv_discard_frag": "\n#ifdef USE_DIFFUSE_MAP\n\t#ifdef UV_DISCARD\n\t\tif (v_Uv.x < 0. || v_Uv.x > 1. || v_Uv.y < 0. || v_Uv.y > 1.) { \n\t\t\tdiscard;\n\t\t}\n\t#endif\n#endif\n"
}